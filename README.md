# CliClock

出处: https://www.52pojie.cn/thread-1050619-1-3.html

协程是啥（内容直接 C-c，C-v）
协程(Coroutine)编译器级的，进程(Process)和线程(Thread)操作系统级的
进程(Process)和线程(Thread)是os通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算，重新开始的地方不可预期，每次CPU计算的指令数量和代码跑过的CPU时间是相关的，跑到os分配的cpu时间到达后就会被os强制挂起，开发者无法精确的控制它们。
协程（Coroutine）是一种轻量级的用户态线程，实现的是非抢占式的调度，即由当前协程切换到其他协程由当前协程来控制。目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。那么谁来适时的切换这些协程？答案是有协程自己主动让出 CPU，也就是每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。

时间片轮转调度
我不知道这是啥啊，噗，只是听上去很帅的样子。和协程相似，应用于底层（操作系统）的话也许名字就叫这个吧。

实现协程的方式
平时的话，其实有很多选择的嘛。比如说 Arduino 玩家会常玩的 ProtoThreads，比较轻量级，使用的 C 语言宏写成，占用资源低，易于移植。还有Libco啥的，其实没用过（捂脸。主要是如果无法理解协程的话，用起来会不怎么得（dei第三声）力。和线程以及RTOS的多任务不同，程序执行过程中不会中断去执行另一个任务。如果阻塞的一个协程的话，可能导致程序无法正常的表达。
自己实现一个协程的话，有助于理解底层原理，以及了解他的弊端。在以后的使用中，可以规避掉这种不正确的使用，写出更优质的代码。